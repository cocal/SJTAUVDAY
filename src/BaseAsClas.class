//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//1. 代码块构与构造函数 -- 代码块会被插入每个构造函数中
//2. 如果构造函数后间相互调用 -- 代码块会被优先插入到最先执行的构造函数中
//3. 带参数的构造函数 可能有个坑。可以看到参数是一个引用。所以穿进来的str 仍然是 “kk” 不是 “kk2”； 
/**
   public BaseAsClas() {
        this(kk);
        System.out.println("2");
    }
    public BaseAsClas(String str) {
        kk = "kk2";
        System.out.println("1 " + kk);
        System.out.println("3");
        System.out.println(str);
    }
**/
//

package com.cocal.logic;

import com.cocal.logic.Sing;
import com.cocal.logic.UserDao;
import javax.annotation.Resource;

public abstract class BaseAsClas {
    public int i;
    public static String kk = "kk";
    @Resource
    protected UserDao userDao;

    public BaseAsClas() {
        this(kk);
        System.out.println("2");
    }

    public BaseAsClas(String str) {
        kk = "kk2";
        System.out.println("1 " + kk);
        System.out.println("3");
        System.out.println(str);
    }

    public UserDao getUserDao() {
        return this.userDao;
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    public static void main(String[] args) {
        new Sing();
    }
}
